МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ЛЬВІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ ІМЕНІ ІВАНА ФРАНКА
ФАКУЛЬТЕТ УПРАВЛІННЯ ФІНАНСАМИ ТА БІЗНЕСУ

Кафедра цифрової економіки та бізнес-аналітики





КУРСОВА РОБОТА
з дисциплін  професійної та практичної підготовки

на тему: 
Інформаційна система продажу автомобілів (Дилерський центр)


спеціальність:                   	051 «Економіка»                                   	          	               
спеціалізація:                    	 «Інформаційні технології в бізнесі»            	                   
освітній ступінь:                   	бакалавр                                                                 	   




Науковий керівник:
к.ф.-м.н., доц. Депутат Б.Я.             
______“___” травня 2023 р.
  (підпис)
 	 	Виконавець:
студент(ка) групи УФЕ-31с Гнатів Н. М.
__________  “___” травня 2023р.
(підпис)
 
Загальна кількість балів _______ __________________________________________________
                                                                                                     (підпис, ПІП членів комісії)


ЛЬВІВ 2023 

ЗМІСТ

ВСТУП	3
1 АНАЛІЗ ВИМОГ	5
1.1.	Постановка завдання	5
1.2.	Розробка моделі варіантів використання веб-сайту	6
1.3.	Аналіз засобів реалізації (техніко-економічне обґрунтування вибору)......	8
1.4.	SWOT-аналіз	12
1.5.	Бізнес-аналіз	15
2	РОЗРОБКА БАЗИ ДАНИХ	16
2.1.	Опис моделі даних	16
2.2.	Нормалізація реляційних відношень	20
2.3.	Обмеження цілісності даних	21
2.4.	Реалізація SQL-скрипту	22
3 РОЗРОБКА ВЕБ-ДОДАТКУ	25
3.1.	Структура веб-сайту	25
3.2.	Програмування серверної частини	25
3.3.	Програмування клієнтської частини	30
ВИСНОВКИ	34
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ	35
ДОДАТОК A	36
ДОДАТОК B	41

ВСТУП

Автомобільна індустрія - це важлива складова економіки країни, а продаж автомобілів є однією з головних галузей цієї індустрії. За останні роки збільшилася кількість автосалонів та дилерських центрів, які займаються продажем автомобілів. Водночас, високий рівень конкуренції вимагає від дилерів не тільки володіти високим рівнем знань про автомобілі та їх характеристики, але й мати зручну та ефективну інформаційну систему продажу автомобілів.
Метою даного дослідження є розробка інформаційної системи продажу автомобілів, яка допоможе підвищити ефективність продажів та покращити якість обслуговування клієнтів. 
Предметом дослідження є теоретичні, методичні та практичні аспекти розробки програмного забезпечення мовою розмітки та створення інтерфейсу: HTML, CSS; мовою програмування: JavaScript, мовою запитів MySql для створення офіційного веб-сайту, а також інформаційна система продажу автомобілів, що включає в себе базу даних автомобілів, засоби пошуку, відображення та фільтрації інформації про автомобілі, можливість оформлення замовлення на автомобіль та інші функції.
Об'єктом дослідження є ринок продажу автомобілів. Ця система включає в себе комплекс програмних та апаратних засобів, які використовуються для збору, обробки та зберігання інформації про автомобілі, їх характеристики, власників, ціни, продавців та покупців.
Отримані результати дослідження щодо інформаційної системи продажу автомобілів можуть бути корисні в декількох ділянках прикладної діяльності. Перш за все, це може бути корисно для автомобільних компаній, дилерів та інших організацій, що займаються продажем автомобілів. Завдяки розробленим рекомендаціям вони можуть поліпшити свої інформаційні системи, що сприятиме покращенню обслуговування клієнтів і збільшенню продажів.

Використане програмне забезпечення: у ході виконання роботи було використано наступний технічний стек: Java, Spring Framework, MySQL, HTML, CSS, JavaScript.
Структура роботи: Курсова робота складається з трьох розділів («Аналіз вимог», «Розробка бази даних» та «Розробка веб-додатку»), висновків, списку використаних джерел, додатків. 
Обсяг роботи становить 50 сторінок.
















1 АНАЛІЗ ВИМОГ

1.1.	Постановка завдання

Завдання курсової роботи на тему "Розробка інформаційної системи продажу автомобілів" включає наступні пункти:
1.	Дослідити існуючі інформаційні системи продажу автомобілів та проаналізувати їх переваги та недоліки.
2.	Сформулювати вимоги до розроблюваної інформаційної системи продажу автомобілів з урахуванням потреб користувачів та вимог ринку.
3.	Розробити концепцію та архітектуру інформаційної системи продажу автомобілів.
4.	Розробити базу даних для зберігання інформації про автомобілі, клієнтів, замовлення та операції з продажу.
5.	Розробити користувацький інтерфейс системи для зручного та швидкого взаємодії з користувачами.
6.	Провести тестування та аналіз ефективності розробленої інформаційної системи продажу автомобілів.

Для даного проекту було надане технічне завдання, яке поділяється на типові запити та розширене завдання. 

Типовими для ІС є запити:
    • Перегляд усіх замовлень, які були зроблені після певної дати.
    • Перегляд імен та електронних адресів клієнтів, які замовили автомобіль з кодом X.
    • Перегляд автомобілів, вартість яких більша за Х.
    • Перегляд автомобілів з маркою X.
    • Список виробників та кількість моделей автомобілів для кожного виробника.
    • Список усіх акаунтів з роллю X.
    • Список клієнтів, які мають більше 5 замовлень.

Розширене завдання:
    • Модель та ціна автомобіля, який має найвищу ціну в таблиці vehicle.
    • Сумарна кількість та сумарна вартість замовлених автомобілів за кожним виробником.
    • Номер замовлення та дату замовлення для тих замовлень, які мають більше ніж один автомобіль в деталях замовлення.
    • Імена та телефони клієнтів, які замовили автомобіль з моделлю Х.
    • Модель та середня ціна замовлених автомобілів для кожної моделі.
    • Ім’я користувача та кількість замовлень, які він зробив за Х рік.

1.2.	Розробка моделі варіантів використання веб-сайту

Use-Case діаграма- це тип діаграми, яка надає візуальне представлення взаємодій і відносин між учасниками, і варіантами використання системи. Це допомагає зрозуміти функціональні вимоги системи та те, як різні актори взаємодіють з нею. Діаграма корисна для збору вимог, проектування системи та спілкування між зацікавленими сторонами, залученими до процесу розробки.

Загалом ми маємо трьох акторів використання:

•	Звичайний користувач – покупець сайту, основний сценарій якого:
Перегляд каталогу –> Додавання покупки до корзини –> Оформлення замовлення -> Оплата замовлення
•	Працівник центру – користувач, що проходить аутентифікацію та до попердніх можливостей у нього додається перегляд та менеджмент замовленнь.

•	Менеджер центру – користувач, що теж проходить відповідну аутентифікацію, до попередніх можливостей додається можливість менеджменту елементами каталогу, тобто зміна та додавання товару.

          Крім того у нас є два зв’язки : «include» та «extend».

«include» дає змогу встановити зв’язок між двома частинами двох різних класів, які повʼязані між собою, тобто покупка авто пов’язана з переглядом товару, додавання його в корзину та оплата.

«extend» дає змогу успадкувати властивості іншого класу та додавати додаткові функції, або змінити існуючі, в нашому випадку додавання та зміна товару.

Опишемо модель варіантів використання за допомогою Use-Case діаграми: 









  

Рис. 1.2.1. Use-Case діаграма використання системи

1.3.	Аналіз засобів реалізації (техніко-економічне обґрунтування вибору)

Для реалізації даної роботи було вибрано наступні технології: 
	Thymeleaf, Bootstrap (Дані технології для реалізації Front-end частини); 
	Java, Spring Framework, MySql, Maven, Tomcat, (Для реалізації Back-end частини).
Для фронт-енд частини було обрано:
	Thymeleaf - це шаблонізатор для веб-програмування, який використовується для створення HTML, XML, Javascript та CSS-файлів з шаблонів, які містять дані та логіку.
Переваги використання Thymeleaf у веб-розробці:
•	Синтаксис Thymeleaf є читабельним та легким для вивчення.
•	Використання Thymeleaf дозволяє розділити логіку та дані між сервером та клієнтом.
•	Thymeleaf надає можливість використовувати звичайні HTML-теги, що робить його легким для розуміння та використання.
•	Thymeleaf підтримує підключення до баз даних та збереження даних у шаблонах.
•	Thymeleaf може використовуватися як у статичних, так і у динамічних веб-сайтах.
•	Thymeleaf підтримує міжнароднізацію, що дозволяє створювати сайти з різними мовами та культурними особливостями.
У загальному, Thymeleaf дозволяє ефективно створювати веб-сайти та додавати логіку до статичних шаблонів, що робить його дуже популярним серед розробників веб-додатків.
	Bootstrap - це найпопулярніший фреймворк для розробки веб-сайтів, який містить набір готових компонентів та стилів для швидкої розробки веб-додатків.
Переваги використання Bootstrap у веб-розробці:
•	Bootstrap забезпечує зручний та легкий для використання сітковий систему, що дозволяє створювати респонсивні та мобільні дизайни.
•	Bootstrap містить велику кількість компонентів та стилів, що дозволяє зменшити час розробки веб-сайтів та зберегти кошти на дизайні.
•	Bootstrap має широкі можливості кастомізації, що дозволяє налаштувати дизайн сайту під власні потреби та вимоги.
•	Bootstrap має велику спільноту розробників, що надає документацію, допомогу та швидкий розвиток фреймворку.
•	Bootstrap підтримує HTML, CSS та JavaScript, що дозволяє розробникам створювати повноцінні веб-сайти без необхідності використання інших фреймворків.
У загальному, Bootstrap є потужним інструментом для швидкої та ефективної розробки веб-додатків. Він дозволяє розробникам створювати привабливі та респонсивні сайти, зменшуючи час та витрати на дизайн та розробку.

Для бек-енд частини було обрано:
	Java - це об'єктно-орієнтована мова програмування, яка була розроблена в компанії Sun Microsystems у 1990-х роках. Java є однією з найбільш популярних мов програмування у світі.
Переваги використання Java у програмуванні:
•	Java є незалежною від платформи, що дозволяє програмістам розробляти програми на будь-якій операційній системі без необхідності змінювати код.
•	Java є об'єктно-орієнтованою мовою програмування, що дозволяє програмістам створювати повторно використовувані компоненти та зменшувати час розробки програм.
•	Java має вбудовану підтримку багатопоточності, що дозволяє програмістам створювати багатопотокові програми для ефективної роботи з багатопоточними задачами.
•	Java має вбудовану систему керування пам'яттю, що дозволяє програмістам уникнути проблем з пам'яттю, таких як витоки пам'яті.
•	Java має велику спільноту програмістів, що надає документацію, підтримку та допомогу в розвитку програм.
У загальному, Java є потужним інструментом для програмування, який дозволяє створювати ефективні, надійні та масштабовані програми для різних платформ. Java є популярним вибором для веб-розробки, розробки мобільних додатків та розробки програмного забезпечення для різних індустрій.
	MySQL - це безкоштовна, відкрита реляційна система управління базами даних (СУБД), яка була розроблена компанією Oracle. MySQL використовує мову SQL для управління базами даних.
Переваги використання MySQL для управління базами даних:
•	MySQL є надійною та стабільною СУБД, яка здатна працювати з великим обсягом даних та забезпечує високу продуктивність.
•	MySQL є безкоштовною та відкритою СУБД, що дозволяє програмістам використовувати її для будь-яких проектів без необхідності платити за ліцензію.
•	MySQL має вбудовану підтримку транзакцій, що дозволяє виконувати операції з базами даних без ризику втрати даних.
•	MySQL має велику спільноту користувачів та програмістів, яка надає підтримку, документацію та допомогу у вирішенні проблем.
•	MySQL має широкі можливості конфігурування та налаштування, що дозволяє програмістам налаштовувати СУБД під конкретні потреби проекту.
У загальному, MySQL є потужним інструментом для управління базами даних, який забезпечує надійність, стабільність та продуктивність. MySQL є популярним вибором для веб-розробки, розробки програмного забезпечення та різних інших проектів, які потребують роботи з базами даних.
	Apache Maven - це інструмент для управління проектами на мові Java, який дозволяє збирати, виконувати та управляти залежностями програмного забезпечення. Maven використовує файл pom.xml (Project Object Model) для опису проекту та його залежностей.
Переваги використання Maven для управління проектами:
•	Простота у використанні та конфігурації проекту, що дозволяє програмістам швидко розпочинати розробку.
•	Maven дозволяє автоматизувати процес збирання та управління залежностями, що дозволяє зменшити ручну роботу та покращити ефективність проекту.
•	Maven має велику кількість плагінів, які дозволяють виконувати різноманітні задачі, такі як тестування, збірка документації, розгортання проекту та інші.
•	Maven дозволяє створювати проекти з використанням шаблонів, що дозволяє швидко створювати нові проекти та забезпечувати їхню структуру.
•	Maven має велику спільноту користувачів та підтримується Apache Software Foundation, що забезпечує надійність та стабільність інструменту.
У загальному, Apache Maven є потужним інструментом для управління проектами на мові Java, який забезпечує простоту у використанні та автоматизацію процесів збирання та управління залежностями. Maven дозволяє програмістам швидко розпочинати розробку та забезпечувати ефективність проекту завдяки великій кількості плагінів та підтримці спільноти.

1.4.	SWOT-аналіз

SWOT-аналіз дає змогу стратегічно планувати, що допомагає оцінити сильні та слабкі сторони, а також можливості та загрози для організації, або будь-якого іншого об'єкта дослідження.
SWOT є абревіатурою, яка має в собі чотири складові :
 • Сильні сторони: конкурентні переваги або позитивні аспекти, які дають змогу відрізнятись від інших. Наприклад, внутрішні ресурси, такі як досвідний персонал, сильний бренд, технологічні переваги або ефективні процеси.
 • Слабкі сторони: обмеження або негативні аспекти, які можуть стати загрозою для організації. Це можуть бути внутрішні проблеми, такі як відсутність ресурсів, слабкі сторони управління, обмежена доступність до ринків тощо.
 • Можливості: зовнішні фактори або умови, які можуть зробити обʼєкт дослідження успішним. Це можуть бути нові ринки, зміни в поведінці споживачів, технологічні тенденції або правові зміни, які можуть сприяти організації.
 • Загрози: зовнішні фактори або умови, які можуть стати ризиком для успіху. Це можуть бути конкурентні позиції, економічні або політичні ризики, швидкі зміни у суспільних уподобаннях або зміни в регулюванні.
SWOT-аналіз дає змогу систематично проаналізувати внутрішнє та зовнішнє середовище проекту, і визначити стратегічні переваги та ризики. 
Отже, визначено слабкі/сильні сторони, можливості та загрози для ринку продажу автомобілів.

 Сильні сторони:
1. Ефективне управління інформацією: інформаційна система дозволяє збирати та аналізувати великі обсяги даних про автомобілі, клієнтів, продажі, рівень запасів, що впливає на полегшення процесу управління та прийняття рішень.
 2. Автоматизація процесів: система дозволяє автоматизувати багато рутинних завдань, таких як обробка замовлень, оновлення баз даних і створення звітів, зменшуючи ймовірність помилок і підвищуючи продуктивність.
 3. Підвищення ефективності продажів: інформаційна система забезпечує зручний доступ до інформації про автомобілі, що дозволяє дилерам швидше та ефективніше обслуговувати клієнтів, надавати необхідну інформацію та здійснювати продажі.
 4. Покращення комунікації з клієнтами: система дозволяє вести базу даних клієнтів, збирати та аналізувати інформацію про їхні потреби та вподобання, що дозволяє покращувати комунікацію з клієнтами та пропонувати індивідуальний підхід.
Слабкі сторони:
1. Висока вартість впровадження: створення та впровадження інформаційних систем може бути досить дорогим, особливо для малих підприємств з обмеженими фінансовими ресурсами.
2. Технологія: якщо система заснована на запатентованому програмному забезпеченні, можуть виникнути проблеми сумісності та оновлення, які вимагають додаткових зусиль підтримки.
3. Потреба в навчанні: потрібні час і ресурси, щоб навчити працівників впроваджувати нові інформаційні системи.


Можливості:
 1. Розширення ринку: інформаційна система дозволить дилеру вийти на нові ринки або залучити нових клієнтів через онлайн-платформу продажу автомобілів.
 2. Покращене обслуговування клієнтів: система дозволяє впроваджувати програми лояльності, забезпечувати швидке обслуговування клієнтів та індивідуальний підхід до кожного клієнта, що може сприяти залученню нових клієнтів та утриманню старих.
 3. Аналіз та звітність: система надає можливість збирати та аналізувати дані про продажі, запаси транспортних засобів, ринковий попит та інші показники, що дозволяє дилеру приймати обґрунтовані рішення та вдосконалювати стратегію продажів.

   Загрози:
 1.  Посилення конкуренції: автомобільний ринок дуже конкурентний, і інші дилерські центри можуть становити серйозну загрозу для вашого бізнесу. Поява нових конкурентів або зростання популярності онлайн-платформ для продажу автомобілів може зменшити вашу частку ринку.
 2. Технологічні проблеми: інформаційну систему необхідно постійно оновлювати та адаптувати до швидкого розвитку технологій. Відсутність сучасних технологій може призвести до втрати клієнтів, оскільки вони можуть віддати перевагу більш технологічно просунутим дилерам.
 3. Зміни в регуляторному середовищі: зміни в законодавстві та регулюванні автомобільної промисловості можуть вплинути на роботу дилерських центрів. Посилення регуляторних обмежень або запровадження нових податків може мати позитивний або негативний вплив на інформаційну систему торгівлі автомобілями.




1.5.	Бізнес-аналіз

З метою дослідження цільової аудиторії було створено опитування за допомогою GoogleForms та опитано 40 респондентів про їхнє відношення до Дилерського центру. Важливим також є те, що таким чином можна вивчити та проаналізувати клієнта.
Опитування показало, що найбільш зацікавленими у Дилерських центрах є населення України від 16 та до 25 років, що становило 57,5% та 70% з них є чоловіки. Заробітна плата у половини населення становить від 300$ до 500$, але і досить велика кількість людей має дуже високу зарплату та всього 42,5% мають вищу освіту. Для більшості респондентів найзручнішим часом для перегляду сайтів є 17:00 та 19:00 та витрачають на перегляд сайту до 1 години на добу. Найважливішим на сайтах є інформація та причиною покупки онлайн є нижча ціна, зручність, та швидкість. Для 60% потенційних клієнтів буде зручною оплата як і готівкою, так і карткою. У 84,5% населення України є авто та більшість полюбляє дизельні автомобілі. Також респонденти виділили, що для покупки авто досить хорошими є сайти auto.ria та olx.ua. 
Отже, провівши опитування можна було дійти до висновку, що найбільшими конкурентами є auto.ria та olx.ua, але ці сайти не є автосалонами, отже не є досить рівносильними конкурентами. Крім того стало зрозуміло, що респонденти є досить зацікавленими в Дилерських центрах, оскільки більшість мають авто. Важливим також висновком стало те, що сайт повинен містити достатню кількість інформації про товар та бути максимально комфортним у використанні.






2	РОЗРОБКА БАЗИ ДАНИХ

2.1.	Опис моделі даних

Проаналізувавши предметну область можна виділити наступні сутності: 
•	Account
•	Order
•	Vehicle

Виділимо атрибути, необхідні даним сутностям: 


Таблиця 2.1.1.
Атрибути сутності «Account»
Account	№	Назва	Тип даних	Опис атрибуту	Додаткові обмеження цілісності
	1	user_name	varchar	Назва користувача	Обов'язковий
	2	active	boolean	Активність	Обов'язковий
	3	Encrypted_password	varchar	Зашифрований пароль	Обов'язковий
	4	User_role	varchar	Роль акаунта	Обов'язковий







Таблиця 2.1.2.
 Атрибути сутності «Vehicle»

Vehicle	№	Назва	Тип даних	Опис атрибуту	Додаткові обмеження цілісності
	1	code	long	Код машини	Первинний ключ
	2	image	blob	Фото машини	Обов'язковий
	3	model	varchar	Модель машини	Обов'язковий
	4	price	double	Ціна	Обов'язковий
	5	Create_date	datetime	Час створення елементу	Обов'язковий

Таблиця 2.1.3. 
Атрибути сутності «Order»

Order	№	Назва	Тип даних	Опис атрибуту	Додаткові обмеження цілісності
	1	id	int	Номер	Первинний ключ
	2	amount	double	Кількість	Обов'язковий
	3	Сustomer_address	varchar	Адреса покупця	Обов'язковий
	4	Сustomer_email	varchar	Пошта покупця	Обов'язковий
	5	Сustomer_name	varchar	Ім’я покупця	Обов'язковий
	6	Сustomer_phone	varchar	Номер телефону покупця	Обов'язковий
	7	date	datetime	Дата 	Обов'язковий
	


Таблиця 2.1.4. 
Атрибути сутності «Order_details»





Order_details






	№	Назва	Тип даних	Опис атрибуту	Додаткові обмеження цілісності
	1	id	varchar	Номер	Первинний ключ
	2	amount	double	Кількість	Обов'язковий
	3	price	double	Ціна	Обов'язковий
	4	Order_id	long	Номер замовлення	Зовнішній ключ
	5	product_id	long	Номер машини	Зовнішній ключ
	

Власне, після проектування отримуємо наступну ER-діаграму:
 
Рис. 2.1.1. ER-діаграма бази даних 
Вміст діаграми  включає в себе опис схеми бази даних для таблиць: order_details, orders та accounts. Описуємо кожну таблицю та її стовпці:
 1.  Таблиця order_details:
 • ID: Стовпець типу VARCHAR(50), який представляє ідентифікатор для кожної деталі замовлення.
 • AMOUNT: Стовпець типу DOUBLE, в якому зберігається сума, пов'язана з деталлю замовлення.
 • PRICE: Стовпець типу DOUBLE, який відображає ціну продукту у деталі замовлення.
 • QUANTITY: Стовпець типу INT, в якому зберігається кількість продукту у деталі замовлення.
 • ORDER_ID: Стовпець типу VARCHAR(50), який посилається на ідентифікатор замовлення, до якого належить деталь.
 • PRODUCT_ID: Стовпець типу VARCHAR(20), який посилається на ідентифікатор продукту, пов'язаного з деталлю замовлення.
 • Індекси: Надана інформація не вказує жодних індексів для цієї таблиці.
 2.  Таблиця orders:
 • ID: Стовпець типу VARCHAR(50), який представляє ідентифікатор для кожного замовлення.
 • AMOUNT: Стовпець типу DOUBLE, в якому зберігається загальна сума замовлення.
 • CUSTOMER_ADDRESS: Стовпець типу VARCHAR(255), в якому зберігається адреса клієнта, що робить замовлення.
 • CUSTOMER_EMAIL: Стовпець типу VARCHAR(128), в якому зберігається електронна пошта клієнта.
 • CUSTOMER_NAME: Стовпець типу VARCHAR(255), в якому зберігається ім'я клієнта.
 • CUSTOMER_PHONE: Стовпець типу VARCHAR(128), в якому зберігається телефонний
 • 
 • ORDER_DATE: Стовпець типу DATETIME, який зберігає дату замовлення.
 • ORDER_NUM: Стовпець типу INT, який представляє номер замовлення.
 • 
           3. Таблиця accounts містить інформацію про користувачів акаунтів. Ось пояснення кожного стовпця:
 • USER_NAME: Стовпець типу VARCHAR(20), який містить ім'я користувача акаунту.
 • ACTIVE: Стовпець типу BIT (1), який вказує, чи є акаунт активним (1) або неактивним (0).
 • ENCRYPTED_PASSWORD: Стовпець типу VARCHAR(128), який містить зашифрований пароль для акаунту.
 • USER_ROLE: Стовпець типу VARCHAR(20), який вказує роль користувача.


2.2.	Нормалізація реляційних відношень

2.1.1.	Перевірка на 1 нормальну форму (1NF):
•	Усі атрибути у таблицях повинні бути атомарними (недільними).
•	У кожній таблиці має бути унікальний ідентифікатор – первинний ключ.
Перша таблиця (account) має атомарні атрибути та первинний ключ, тому вона знаходиться в 1NF.
Друга таблиця (vehicle) також має атомарні атрибути та первинний ключ, тому вона також знаходиться в 1NF.
Третя таблиця (order) має атомарні атрибути та первинний ключ, тому вона також знаходиться в 1NF.
Четверта таблиця (order_details) має атомарні атрибути та первинний ключ, тому вона також знаходиться в 1NF.
Отже, всі три таблиці знаходяться в 1 нормальній формі.

2.1.2.	Перевірка на 2 нормальну форму (2NF):
•	Таблиця повинна знаходитися в 1NF.
•	Кожний неключовий атрибут повинен залежати від первинного ключа в цілому, а не від окремих його атрибутів.
У таблиці account всі атрибути залежать від первинного ключа, тому вона знаходиться в 2NF.
У таблиці vehicle також всі атрибути залежать від первинного ключа, тому вона знаходиться в 2NF.
І у таблиці order всі атрибути залежать від первинного ключа, тому вона знаходиться в 2NF.
2.1.3.	Перевірка на 3 нормальну форму (3NF):
•	Таблиця повинна знаходитися в 2NF.
•	Кожен неключовий атрибут повинен залежати від первинного ключа безпосередньо, а не через інші атрибути.
У таблиці account всі атрибути залежать від первинного ключа (vin), тому вона знаходиться в 3NF.
У таблиці vehicle всі атрибути залежать від первинного ключа (customer_id), тому вона знаходиться в 3NF.
У таблиці order всі атрибути залежать від первинного ключа, тому вона знаходиться в 3NF.

2.3.	Обмеження цілісності даних

Для реалізації цілісності даних нам необхідні наступні обмеження: 
Для таблиці vehicle:
1.	odometer повинен бути додатнім числом або 0, тому додамо обмеження CHECK:
ALTER TABLE vehicle ADD CONSTRAINT odometer_positive CHECK > 0);
2.	price повинен бути додатнім числом, тому додамо обмеження CHECK:
ALTER TABLE vehicle ADD CONSTRAINT price_positive CHECK (price > 0); 
Для таблиці customer:
1.	purchase_price повинен бути додатнім числом, тому додамо обмеження CHECK:
ALTER TABLE customer ADD CONSTRAINT purchase_price_positive CHECK (purchase_price > 0); 
2.	phone_number повинен бути унікальним, тому додамо обмеження UNIQUE:
ALTER TABLE customer ADD CONSTRAINT phone_number_unique UNIQUE (phone_number); 
Для таблиці sale:
1.	amount повинен бути додатнім числом, тому додамо обмеження CHECK:
ALTER TABLE sale ADD CONSTRAINT amount_positive CHECK (amount > 0); 
2.	isDiscounted повинен бути значенням 0 або 1 (тобто, відповідно до типу BOOL), тому додамо обмеження CHECK:
ALTER TABLE sale ADD CONSTRAINT isDiscounted_boolean CHECK (isDiscounted IN (0,1)); 
3.	customer_ID повинен посилатися на існуючий запис у таблиці customer, тому додамо обмеження FOREIGN KEY:
ALTER TABLE sale ADD CONSTRAINT customer_ID_fk FOREIGN KEY (customer_ID) REFERENCES customer(customer_id); 
4.	vehicle_ID повинен посилатися на існуючий запис у таблиці vehicle, тому додамо обмеження FOREIGN KEY:
ALTER TABLE sale ADD CONSTRAINT vehicle_ID_fk FOREIGN KEY (vehicle_ID) REFERENCES vehicle(vin)

2.4.	Реалізація SQL-скрипту

SQL скрипт – це набір команд, які виконуються в базі даних для створення, зміни або отримання інформації. Він дозволяє програмістам взаємодіяти з базою даних, виконуючи запити і оператори для створення, оновлення та видалення даних. SQL скрипти можуть включати створення таблиць, внесення даних, зміну структури таблиць, виконання складних запитів та інші операції, що дозволяють ефективно управляти та аналізувати дані в базі даних.

Типовими для ІС є запити:
•	Перегляд усіх замовлень, які були зроблені після певної дати.
SELECT * FROM orders WHERE order_date > ‘2023-01-01’;
•	Перегляд імен та електронних адресів клієнтів, які замовили автомобіль з кодом X
SELECT customer_name, customer_email FROM orders
JOIN order_details ON orders.id = order_details.order_id
WHERE order_details.product_id = ‘V001';
•	Перегляд автомобілів, вартість яких більша за Х
SELECT * FROM vehicle WHERE price > 100000;
•	Перегляд автомобілів з маркою X.
SELECT * FROM vehicle WHERE model = 'Tesla Model 3';
•	Список виробників та кількість моделей автомобілів для кожного виробника.
SELECT manufacturer, COUNT(*) AS model_count FROM vehicle
GROUP BY manufacturer;
•	Список усіх акаунтів з роллю X
SELECT * FROM accounts WHERE user_role = 'USER';
•	Список клієнтів, які мають більше 5 замовлень
SELECT customer_name FROM orders
GROUP BY customer_name
HAVING COUNT(*) > 5;

  Розширене завдання:
•	Модель та ціна автомобіля, який має найвищу ціну в таблиці vehicle
SELECT model, price FROM vehicle
WHERE price = (SELECT MAX(price) FROM vehicle);
•	Сумарна кількість та сумарна вартість замовлених автомобілів за кожним виробником
SELECT manufacturer, SUM(quanity) AS total_quanity, SUM(amount) AS total_amount FROM vehicle
JOIN order_details ON vehicle.code = order_details.product_id
GROUP BY manufacturer;
•	Номер замовлення та дату замовлення для тих замовлень, які мають більше ніж один автомобіль в деталях замовлення
SELECT order_num, order_date FROM orders
WHERE id IN (SELECT order_id FROM order_details GROUP BY order_id HAVING COUNT(*) > 1);
•	 Імена та телефони клієнтів, які замовили автомобіль з моделлю Х
SELECT customer_name, customer_phone FROM orders
JOIN order_details ON orders.id = order_details.order_id
JOIN vehicle ON order_details.product_id = vehicle.code
WHERE vehicle.model = 'Tesla Model 3';
•	 Модель та середня ціна замовлених автомобілів для кожної моделі.
SELECT model, AVG(price) AS average_price FROM vehicle
JOIN order_details ON vehicle.code = order_details.product_id
GROUP BY model;
•	 Ім’я користувача та кількість замовлень, які він зробив за Х рік
SELECT user, COUNT(*) AS order_count FROM accounts
JOIN orders ON accounts.user = orders.customer_email
WHERE YEAR(order_date) = 2023
GROUP BY user.
Повний SQL-скрипт для створення бази даних знаходиться у Додатку А.

3 РОЗРОБКА ВЕБ-ДОДАТКУ

3.1.	Структура веб-сайту

Для реалізації зазначеного у пункті 1.2. функціоналу нам необхідні наступні веб-сторінки: 
•	Додавання машини
•	«Домашня» сторінка сайту
•	Каталог усіх машин
•	Корзина
•	Профіль користувача
•	Створення та оплата замовлення
•	Перегляд усіх замовлень


3.2.	Програмування серверної частини

Для програмування даної інформаційної системи було використано MVC-архітектуру, що реалізовано за допомогою різних частин фреймворку Spring.
 	Перш за все, реалізуємо шар entity – класи сутностей, що пов'язані з відповідними таблицями БД.
Далі необхідно реалізувати шар repository. Так як ми користуємося можливостями Spring Data JPA, то репозиторії, пов'язані з відповідними сутностями, імплементують інтерфейс JPARepository, який надає певні методи для взаємодії з БД.
Після цього відповідно реалізуємо модуль services, що відповідатиме за логіку застосунку. 
Наступним кроком можемо приступати до реалізації контролерів, що взаємодіятимуть із клієнтською частиною за допомогою ендпоінтів.
Наприклад, endpoint для додавання елементів у каталог:

@RequestMapping(value = { "/admin/product" }, method = RequestMethod.POST)
public String productSave(Model model, //
                          @ModelAttribute("productForm") @Validated VehicleForm vehicleForm, //
                          BindingResult result, //
                          final RedirectAttributes redirectAttributes) {

   if (result.hasErrors()) {
      return "product";
   }
   try {
      vehicleDAO.save(vehicleForm);
   } catch (Exception e) {
      Throwable rootCause = ExceptionUtils.getRootCause(e);
      String message = rootCause.getMessage();
      model.addAttribute("errorMessage", message);
      // Show product form.
      return "product";
   }

   return "redirect:/productList";
}

Лістинг 3.2.1. Endpoint з POST-мапінгом 

Також, важливими особливостями цього проекту, про які не згадувалось раніше є 
•	валідація даних при створенні нового елементу каталогу або при заповненні даних для замовлення

•	@Override
public void validate(Object target, Errors errors) {
   VehicleForm vehicleForm = (VehicleForm) target;

   // Check the fields of ProductForm.
   ValidationUtils.rejectIfEmptyOrWhitespace(errors, "code", "NotEmpty.productForm.code");
   ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "NotEmpty.productForm.name");
   ValidationUtils.rejectIfEmptyOrWhitespace(errors, "price", "NotEmpty.productForm.price");

   String code = vehicleForm.getCode();
   if (code != null && code.length() > 0) {
      if (code.matches("\\s+")) {
         errors.rejectValue("code", "Pattern.productForm.code");
      } else if (vehicleForm.isNewProduct()) {
         Vehicle vehicle = vehicleDAO.findVehicle(code);
         if (vehicle != null) {
            errors.rejectValue("code", "Duplicate.productForm.code");
         }
      }
   }
}

Лістинг 3.2.2. Валідація машин при додаванні

•	реалізація можливості оплати за допомогою PayPal.
•	пагінація при виводі елементів каталогу або при виведенні списку замовлень

•	package com.example.demo.pagination;

import java.util.ArrayList;
import java.util.List;
import org.hibernate.ScrollMode;
import org.hibernate.ScrollableResults;
import org.hibernate.query.Query;

public class PaginationResult<E> {
      private int totalRecords;
      private int currentPage;
      private List<E> list;
      private int maxResult;
      private int totalPages;
    
      private int maxNavigationPage;
    
      private List<Integer> navigationPages;
    
      // @page: 1, 2, ..
      public PaginationResult(Query<E> query, int page, int maxResult, int maxNavigationPage) {
         final int pageIndex = Math.max(page - 1, 0);
         int fromRecordIndex = pageIndex * maxResult;
         int maxRecordIndex = fromRecordIndex + maxResult;
         ScrollableResults resultScroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE);
    
         List<E> results = new ArrayList<>();
    
         boolean hasResult = resultScroll.first();
    
         if (hasResult) {
            // Scroll to position:
            hasResult = resultScroll.scroll(fromRecordIndex);
    
            if (hasResult) {
               do {
                  E record = (E) resultScroll.get(0);
                  results.add(record);
               } while (resultScroll.next()//
                     && resultScroll.getRowNumber() >= fromRecordIndex
                     && resultScroll.getRowNumber() < maxRecordIndex)
            }
    
            // Go to Last record.
            resultScroll.last();
         }
    
         // Total Records
         this.totalRecords = resultScroll.getRowNumber() + 1;
         this.currentPage = pageIndex + 1;
         this.list = results;
         this.maxResult = maxResult;
    
         if (this.totalRecords % this.maxResult == 0) {
            this.totalPages = this.totalRecords / this.maxResult;
         } else {
            this.totalPages = (this.totalRecords / this.maxResult) + 1;
         }
    
         this.maxNavigationPage = maxNavigationPage;
    
         if (maxNavigationPage < totalPages) {
            this.maxNavigationPage = maxNavigationPage;
         }
    
         this.calcNavigationPages();
      }
    
      private void calcNavigationPages() {
    
         this.navigationPages = new ArrayList<Integer>();
    
         int current = Math.min(this.currentPage, this.totalPages);
    
         int begin = current - this.maxNavigationPage / 2;
         int end = current + this.maxNavigationPage / 2;
    
         // The first page
         navigationPages.add(1);
         if (begin > 2) {
    
            // Using for '...'
            navigationPages.add(-1);
         }
    
         for (int i = begin; i < end; i++) {
            if (i > 1 && i < this.totalPages) {
               navigationPages.add(i);
            }
         }
    
         if (end < this.totalPages - 2) {
    
            // Using for '...'
            navigationPages.add(-1);
         }
         // The last page.
         navigationPages.add(this.totalPages);
      }
    
      public int getTotalPages() {
         return totalPages;
      }
    
      public int getTotalRecords() {
         return totalRecords;
      }
    
      public int getCurrentPage() {
         return currentPage;
      }
    
      public List<E> getList() {
         return list;
      }
    
      public int getMaxResult() {
         return maxResult;
      }
    
      public List<Integer> getNavigationPages() {
         return navigationPages;
      }
    
   }

Лістинг 3.2.3. Реалізація пагінації
Нижче наведено структуру проекту у вигляді діаграми класів.
 

Рис. 3.2.1.  Діаграма класів додатку 

3.3.	Програмування клієнтської частини

Для реалізації клієнтської частини було обрано технологію, Thymeleaf,  що є технологією веб-розробки на мові Java, яка дозволяє створювати динамічні веб-сторінки. 
Результати розробки клієнтської частини:

 

Рис. 3.3.1. «Домашня» сторінка
 
Рис. 3.3.2. Каталог машин
 
Рис. 3.3.3. Корзина покупця
 
Рис. 3.3.4. Оформлення замовлення

 
Рис. 3.3.5. Авторизація
 
Рис. 3.3.6. Створення нового елементу каталогу

 
Рис. 3.3.7. Перегляд списку замовлень
ВИСНОВКИ

Якщо розглядати висновки до курсової роботи з розробки інформаційної системи продажу авто, то основні пункти, які можна виділити, наступні:
•	Розробка інформаційної системи продажу авто є складним та багатоетапним процесом, який вимагає від розробника високого рівня знань та досвіду в області веб-розробки, баз даних, архітектури та дизайну.
•	В процесі розробки було створено інформаційну систему продажу авто, яка дозволяє користувачам швидко та зручно здійснювати пошук та покупку автомобілів.
•	Під час розробки було використано ряд сучасних технологій та інструментів, включаючи мову програмування Java, фреймворк Spring, базу даних MySQL, сервер додатків Apache Tomcat, Thymeleaf, Bootstrap.
•	Результатом розробки є повноцінна інформаційна система продажу авто, яка може бути використана як для комерційних, так і для особистих цілей.
•	Наступним кроком може бути розширення функціональності системи, додавання нових функцій та модулів, а також покращення інтерфейсу користувача та оптимізація продуктивності системи.











ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ

1.	Патерни проектування [Електронний ресурс]. – Режим доступу: https://refactoring.guru/uk/design-patterns/factory-method
2.	The Persistence Layer with Spring Data JPA [Електронний ресурс].  – Режим доступу: https://for-each.dev/lessons/b/-the-persistence-layer-with-spring-data-jpa/
3.	Java [Електронний ресурс]. – Режим доступу:
      https://uk.wikipedia.org/wiki/Java
4.	 IntelliJ IDEA [Електронний ресурс]. – Режим доступу:
      https://uk.wikipedia.org/wiki/IntelliJ_IDEA
 
ДОДАТОК A

Скрипт Orders
CREATE DATABASE  IF NOT EXISTS `car_dealership` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `car_dealership`;
-- MySQL dump 10.13  Distrib 8.0.29, for Win64 (x86_64)
--
-- Host: 127.0.0.1    
-- ------------------------------------------------------
-- Server version  8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `orders`
--

DROP TABLE IF EXISTS `orders`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `orders` (
  `ID` varchar(50) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `AMOUNT` double NOT NULL,
  `CUSTOMER_ADDRESS` varchar(255) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `CUSTOMER_EMAIL` varchar(128) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `CUSTOMER_NAME` varchar(255) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `CUSTOMER_PHONE` varchar(128) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `ORDER_DATE` datetime NOT NULL,
  `ORDER_NUM` int NOT NULL,
  PRIMARY KEY (`ID`),
  UNIQUE KEY `ORDER_UK` (`ORDER_NUM`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `orders`
--

LOCK TABLES `orders` WRITE;
/*!40000 ALTER TABLE `orders` DISABLE KEYS */;
/*!40000 ALTER TABLE `orders` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-03-28 23:50:39

 Скрипт Accounts
CREATE DATABASE  IF NOT EXISTS `car_dealership` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `car_dealership`;
-- MySQL dump 10.13  Distrib 8.0.29, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: spring_shoppingcartdb2
-- ------------------------------------------------------
-- Server version  8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `accounts`
--

DROP TABLE IF EXISTS `accounts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `accounts` (
  `USER_NAME` varchar(20) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `ACTIVE` bit(1) NOT NULL,
  `ENCRYTED_PASSWORD` varchar(128) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `USER_ROLE` varchar(20) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  PRIMARY KEY (`USER_NAME`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accounts`
--

LOCK TABLES `accounts` WRITE;
/*!40000 ALTER TABLE `accounts` DISABLE KEYS */;
INSERT INTO `accounts` VALUES ('employee1',_binary '','$2a$10$PrI5Gk9L.tSZiW9FXhTS8O8Mz9E97k2FZbFvGFFaSsiTUIl.TCrFu','ROLE_EMPLOYEE'),('manager1',_binary '','$2a$10$PrI5Gk9L.tSZiW9FXhTS8O8Mz9E97k2FZbFvGFFaSsiTUIl.TCrFu','ROLE_MANAGER');
/*!40000 ALTER TABLE `accounts` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-03-28 23:50:39

Cкрипт Vehicle
CREATE DATABASE  IF NOT EXISTS `car_dealership` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `car_dealership`;
-- MySQL dump 10.13  Distrib 8.0.29, for Win64 (x86_64)
--
-- Host: 127.0.0.1   
-- ------------------------------------------------------
-- Server version  8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `vehicle`
--

DROP TABLE IF EXISTS `vehicle`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `vehicle` (
  `CODE` varchar(20) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `IMAGE` longblob,
  `MODEL` varchar(255) COLLATE latin1_general_ci NOT NULL,
  `PRICE` double NOT NULL,
  `CREATE_DATE` datetime NOT NULL,
  `MANUFACTURER` varchar(50) COLLATE latin1_general_ci DEFAULT NULL,
  PRIMARY KEY (`CODE`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `vehicle`
--

LOCK TABLES `vehicle` WRITE;
/*!40000 ALTER TABLE `vehicle` DISABLE KEYS */;
/*!40000 ALTER TABLE `vehicle` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-03-28 23:50:39

Скрипт Order_details
CREATE DATABASE  IF NOT EXISTS `car_dealership` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `car_dealership`;
-- MySQL dump 10.13  Distrib 8.0.29, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: spring_shoppingcartdb2
-- ------------------------------------------------------
-- Server version  8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `order_details`
--

DROP TABLE IF EXISTS `order_details`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `order_details` (
  `ID` varchar(50) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `AMOUNT` double NOT NULL,
  `PRICE` double NOT NULL,
  `QUANITY` int NOT NULL,
  `ORDER_ID` varchar(50) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `PRODUCT_ID` varchar(20) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `ORDER_DETAIL_ORD_FK` (`ORDER_ID`),
  KEY `ORDER_DETAIL_PROD_FK` (`PRODUCT_ID`),
  CONSTRAINT `ORDER_DETAIL_ORD_FK` FOREIGN KEY (`ORDER_ID`) REFERENCES `orders` (`ID`),
  CONSTRAINT `ORDER_DETAIL_PROD_FK` FOREIGN KEY (`PRODUCT_ID`) REFERENCES `vehicle` (`CODE`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `order_details`
--

LOCK TABLES `order_details` WRITE;
/*!40000 ALTER TABLE `order_details` DISABLE KEYS */;
/*!40000 ALTER TABLE `order_details` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-03-28 23:50:39




















ДОДАТОК B
Клас WebConfiguration
package com.example.demo.config;

import org.springframework.context.MessageSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfiguration implements WebMvcConfigurer {
 
    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
        // Load file: validation.properties
        messageSource.setBasename("classpath:validation");
        messageSource.setDefaultEncoding("UTF-8");
        return messageSource;
    }
  
}

Клас WebSecurityConfig
package com.example.demo.config;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import com.example.demo.service.UserDetailsServiceImpl;

@Configuration
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
   @Autowired
      UserDetailsServiceImpl userDetailsService;
    
      @Bean
      public BCryptPasswordEncoder passwordEncoder() {
         BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
         return bCryptPasswordEncoder;
      }
    
      @Autowired
      public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    
         // Setting Service to find User in the database.
         // And Setting PassswordEncoder
         auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    
      }
    
      @Override
      protected void configure(HttpSecurity http) throws Exception {
    
         http.csrf().disable();
    
         // Requires login with role ROLE_EMPLOYEE or ROLE_MANAGER.
         // If not, it will redirect to /admin/login.
         http.authorizeRequests().antMatchers("/admin/orderList", "/admin/order", "/admin/accountInfo")//
               .access("hasAnyRole('ROLE_EMPLOYEE', 'ROLE_MANAGER')");
    
         // Pages only for MANAGER
         http.authorizeRequests().antMatchers("/admin/product").access("hasRole('ROLE_MANAGER')");
    
         // When user login, role XX.
         // But access to the page requires the YY role,
         // An AccessDeniedException will be thrown.
         http.authorizeRequests().and().exceptionHandling().accessDeniedPage("/403");
    
         // Configuration for Login Form.
         http.authorizeRequests().and().formLogin()//
    
               //
               .loginProcessingUrl("/j_spring_security_check") // Submit URL
               .loginPage("/admin/login")//
               .defaultSuccessUrl("/admin/accountInfo")//
               .failureUrl("/admin/login?error=true")//
               .usernameParameter("userName")//
               .passwordParameter("password")
    
               // Configuration for the Logout page.
               // (After logout, go to home page)
               .and().logout().logoutUrl("/admin/logout").logoutSuccessUrl("/");
    
      }
}

Клас Account
package com.example.demo.entity;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Accounts")
public class Account implements Serializable {
 
    private static final long serialVersionUID = -2054386655979281969L;
 
    public static final String ROLE_MANAGER = "MANAGER";
    public static final String ROLE_EMPLOYEE = "EMPLOYEE";
 
    @Id
    @Column(name = "User_Name", length = 20, nullable = false)
    private String userName;
 
    @Column(name = "Encryted_Password", length = 128, nullable = false)
    private String encrytedPassword;
 
    @Column(name = "Active", length = 1, nullable = false)
    private boolean active;
 
    @Column(name = "User_Role", length = 20, nullable = false)
    private String userRole;
 
    public String getUserName() {
        return userName;
    }
 
    public void setUserName(String userName) {
        this.userName = userName;
    }
 
    public String getEncrytedPassword() {
        return encrytedPassword;
    }
 
    public void setEncrytedPassword(String encrytedPassword) {
        this.encrytedPassword = encrytedPassword;
    }
 
    public boolean isActive() {
        return active;
    }
 
    public void setActive(boolean active) {
        this.active = active;
    }
 
    public String getUserRole() {
        return userRole;
    }
 
    public void setUserRole(String userRole) {
        this.userRole = userRole;
    }
 
    @Override
    public String toString() {
        return "[" + this.userName + "," + this.encrytedPassword + "," + this.userRole + "]";
    }
 
}
Клас Vehicle
package com.example.demo.entity;

import java.io.Serializable;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

@Entity
@Table(name = "Vehicle")
public class Vehicle implements Serializable {
 
    private static final long serialVersionUID = -1000119078147252957L;
 
    @Id
    @Column(name = "Code", length = 20, nullable = false)
    private String code;
 
    @Column(name = "MODEL", length = 255, nullable = false)
    private String name;
 
    @Column(name = "Price", nullable = false)
    private double price;
 
    @Lob
    @Column(name = "Image", length = Integer.MAX_VALUE, nullable = true)
    private byte[] image;
     
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "Create_Date", nullable = false)
    private Date createDate;
 
    public Vehicle() {
    }
 
    public String getCode() {
        return code;
    }
 
    public void setCode(String code) {
        this.code = code;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public double getPrice() {
        return price;
    }
 
    public void setPrice(double price) {
        this.price = price;
    }
 
    public Date getCreateDate() {
        return createDate;
    }
 
    public void setCreateDate(Date createDate) {
        this.createDate = createDate;
    }
 
    public byte[] getImage() {
        return image;
    }
 
    public void setImage(byte[] image) {
        this.image = image;
    }
 
}

Клас Order
package com.example.demo.entity;

import java.io.Serializable;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "Orders", //
        uniqueConstraints = { @UniqueConstraint(columnNames = "Order_Num") })
public class Order implements Serializable {
 
    private static final long serialVersionUID = -2576670215015463100L;
 
    @Id
    @Column(name = "ID", length = 50)
    private String id;
 
    @Column(name = "Order_Date", nullable = false)
    private Date orderDate;
 
    @Column(name = "Order_Num", nullable = false)
    private int orderNum;
 
    @Column(name = "Amount", nullable = false)
    private double amount;
 
    @Column(name = "Customer_Name", length = 255, nullable = false)
    private String customerName;
 
    @Column(name = "Customer_Address", length = 255, nullable = false)
    private String customerAddress;
 
    @Column(name = "Customer_Email", length = 128, nullable = false)
    private String customerEmail;
 
    @Column(name = "Customer_Phone", length = 128, nullable = false)
    private String customerPhone;
 
    public String getId() {
        return id;
    }
 
    public void setId(String id) {
        this.id = id;
    }
 
    public Date getOrderDate() {
        return orderDate;
    }
 
    public void setOrderDate(Date orderDate) {
        this.orderDate = orderDate;
    }
 
    public int getOrderNum() {
        return orderNum;
    }
 
    public void setOrderNum(int orderNum) {
        this.orderNum = orderNum;
    }
 
    public double getAmount() {
        return amount;
    }
 
    public void setAmount(double amount) {
        this.amount = amount;
    }
 
    public String getCustomerName() {
        return customerName;
    }
 
    public void setCustomerName(String customerName) {
        this.customerName = customerName;
    }
 
    public String getCustomerAddress() {
        return customerAddress;
    }
 
    public void setCustomerAddress(String customerAddress) {
        this.customerAddress = customerAddress;
    }
 
    public String getCustomerEmail() {
        return customerEmail;
    }
 
    public void setCustomerEmail(String customerEmail) {
        this.customerEmail = customerEmail;
    }
 
    public String getCustomerPhone() {
        return customerPhone;
    }
 
    public void setCustomerPhone(String customerPhone) {
        this.customerPhone = customerPhone;
    }
 
}

Клас OrderDeatail
package com.example.demo.entity;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ForeignKey;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "Order_Details")
public class OrderDetail implements Serializable {
 
    private static final long serialVersionUID = 7550745928843183535L;
 
    @Id
    @Column(name = "ID", length = 50, nullable = false)
    private String id;
 
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORDER_ID", nullable = false, //
            foreignKey = @ForeignKey(name = "ORDER_DETAIL_ORD_FK"))
    private Order order;
 
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PRODUCT_ID", nullable = false, //
            foreignKey = @ForeignKey(name = "ORDER_DETAIL_PROD_FK"))
    private Vehicle vehicle;
 
    @Column(name = "Quanity", nullable = false)
    private int quanity;
 
    @Column(name = "Price", nullable = false)
    private double price;
 
    @Column(name = "Amount", nullable = false)
    private double amount;
 
    public String getId() {
        return id;
    }
 
    public void setId(String id) {
        this.id = id;
    }
 
    public Order getOrder() {
        return order;
    }
 
    public void setOrder(Order order) {
        this.order = order;
    }
 
    public Vehicle getProduct() {
        return vehicle;
    }
 
    public void setProduct(Vehicle vehicle) {
        this.vehicle = vehicle;
    }
 
    public int getQuanity() {
        return quanity;
    }
 
    public void setQuanity(int quanity) {
        this.quanity = quanity;
    }
 
    public double getPrice() {
        return price;
    }
 
    public void setPrice(double price) {
        this.price = price;
    }
 
    public double getAmount() {
        return amount;
    }
 
    public void setAmount(double amount) {
        this.amount = amount;
    }
 
}

Клас CustomerForm
package com.example.demo.form;

import com.example.demo.model.CustomerInfo;

public class CustomerForm {
    
    private String name;
    private String address;
    private String email;
    private String phone;
 
    private boolean valid;
 
    public CustomerForm() {
 
    }
 
    public CustomerForm(CustomerInfo customerInfo) {
        if (customerInfo != null) {
            this.name = customerInfo.getName();
            this.address = customerInfo.getAddress();
            this.email = customerInfo.getEmail();
            this.phone = customerInfo.getPhone();
        }
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public String getEmail() {
        return email;
    }
 
    public void setEmail(String email) {
        this.email = email;
    }
 
    public String getAddress() {
        return address;
    }
 
    public void setAddress(String address) {
        this.address = address;
    }
 
    public String getPhone() {
        return phone;
    }
 
    public void setPhone(String phone) {
        this.phone = phone;
    }
 
    public boolean isValid() {
        return valid;
    }
 
    public void setValid(boolean valid) {
        this.valid = valid;
    }
 
}

Клас VehicleForm
package com.example.demo.form;

import com.example.demo.entity.Vehicle;
import org.springframework.web.multipart.MultipartFile;

public class VehicleForm {
    private String code;
    private String name;
    private double price;
 
    private boolean newProduct = false;
 
    // Upload file.
    private MultipartFile fileData;
 
    public VehicleForm() {
        this.newProduct= true;
    }
 
    public VehicleForm(Vehicle vehicle) {
        this.code = vehicle.getCode();
        this.name = vehicle.getName();
        this.price = vehicle.getPrice();
    }
 
    public String getCode() {
        return code;
    }
 
    public void setCode(String code) {
        this.code = code;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public double getPrice() {
        return price;
    }
 
    public void setPrice(double price) {
        this.price = price;
    }
 
    public MultipartFile getFileData() {
        return fileData;
    }
 
    public void setFileData(MultipartFile fileData) {
        this.fileData = fileData;
    }
 
    public boolean isNewProduct() {
        return newProduct;
    }
 
    public void setNewProduct(boolean newProduct) {
        this.newProduct = newProduct;
    }

}
